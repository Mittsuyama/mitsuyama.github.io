计算机系统基础
Computer | Note
主要学习《深入理解计算机系统》。这本书的主要论题包括：数据表示、C 程序的机器级表示、处理器结构，程序优化、存储器层次结构、链接、异常控制流、虚拟存储器和存储器管理、系统级 I/O、网络编程和并发编程。书中所覆盖的内容主要是这些方面是如何影响应用和系统程序员的。
2019/3/11



## 信息的标识和处理：位、整数

主要内容：位、字节、整数型

其他内容：信息的位标识、位级运算、整形数（标识，无符号与有符号数，扩展与截断，整数运算）、内存、指针、字符串表示

##### 位、字节、字

1. **「位」或者「比特」**：<u>最底层</u>的二进制数字（数码）称为位（bit，比特），值位 0 或 1；
2. **位组合**：把位组合在一起，采用某种规则进行解读
3. **字节**：8-bit 块（1bytes = 8bits）
4. **字**：CPU 中 ALU（Arithmetic Logic Unit）的数据位数 = CPU 中通用寄存器的位数（通常说计算机是 XX 位的，是指这台计算机 CPU 字的长度 OS 是 XX 位的，是指其 CPU 的工作模式，这与操作系统各 DLL [Dynamic Link Library] 库函数、编译连接环境有关）



在汇编语言、机器语言编程中，一个字指的是 16 位。数据存放时高字节在高地址、低字节在低地址。

##### 进制

MSB（Most Significant Bit）：最高有效位

LSB（Least Significant Bit）：最低有效位



二进制（B）：便于存储，算术运算简单，支持逻辑运算

十六进制（H）：与二进制互转简单，阅读书写方便

##### 计算机内的数值表示 —— 编码

需要考虑的问题：编码的长度、数的符号、数的运算



一般数据类型和运算（略）

#### 浮点数的表示

![image-20190331152753273](../img/image-20190331152753273.png)

表示成有理数的形式：
$$
(-1)^S \; 2^E \; M
$$
其中：

S（符号 Sign）：决定正负

E（Exponent）：用 $2^E$ 将数值加权

M（位数 Significant）：二进制小数，数据范围 $[1.0, 2.0)$

##### 浮点编码

1. 最高有效位（MSB），最为符号位 s
2. exp 字段，编码 E（E 与 exp 不相等）
3. frac 字段编码尾数 M（与 M 也不一定相等）

##### 精度选项

单精度：32 bits（1 + 8 + 23）

双精度：64 bits（1 + 11 + 52）

扩展精度：80 bits（1 + 15 + 63/64）

##### 阶码（移码）

举个例子，exp 如何表示 -126

1. 真值：-126
2. 补码：10000010
3. 移码 + 128：00000010
4. 移码 + 127：00000001
5. 机器数：1

没有 -127，-128，空出 0000000 和 1111111

##### 规格化数

条件：exp ≠ 000…0 且 exp ≠ 111…1

阶码采用偏置值编码：E = Exp - Bias

$T = (-1)^S \times 2^{Bias + E} \times M$

##### 非规格化数

1. exp = 000...0，frac = 000...0：表示 0（`注意`：有 +0  和 -0 之分）
2. exp = 000...0，frac ≠ 000...0：表示最接近 0.0 的那些数（$frac * 2^{-126}$）
3. exp = 111…1，frac = 000...0：表示正负无穷
4. exp = 111…1，frac = 000...0：表示 Not a Number (NaN)

##### 默认的舍入模式

1. 恰好在两个可能数值中间时（中间值）：舍入后，最低有效位的数码位偶数
2. 其他的时候，像最近的数值舍入（比中间值小向下舍入，比中间值大向上舍入）

举例：

7/8：10.11**110** → 11.0**0** → 3

5/8：10.10**110** → 10.1**0** → 2

##### 浮点的运算

（看书）

## 程序的机器级表示

### 基础

##### Intel x86 处理器

复杂指令集计算机（Complex instruction set computer，CISC）

1. 指令多、指令格式多（Linux 程序设计只用到较小子集）
2. 性能难与精简指令计算机（Reduced Instruction Set Computer，RISC）相比

##### 8086/8

8086/8 内部有两个功能模块，完成一条指令的取值和执行功能

1. 模块之一：总线结构单元 BIU，主要负责读取指令和操作数
2. 模块之二：执行单元 EU，主要负责指令译码和执行

##### 8086 的寄存器组

对于汇编语言程序来说，8086 内部结构就是可编程的寄存器组

1. 执行单元 EU 8 个通用寄存器
2. 1 个指令指针寄存器
3. 1 个标志寄存器
4. 4 个段寄存器 / 64 位增加了 fs/gs 也成 16 位
5. `注意` 32 / 64 位 CPU 对通用寄存器记性了位扩展，64 位增加了 R8 - R15 共 8 个寄存器

#### 8086 的通用寄存器

8086 的 16 位通用寄存器是：

1. AX（Accumulator Register）：累加寄存器，使用频率最高，常用于运算；在乘除等指令中用来存放操作数，另外，所有的 I/O 指令都使用这一寄存器与外界设备传送数据。
2. BX（Base）：基址寄存器，常用于存放村粗器地址、地址索引，数组首地址
3. CX（Count）：计数寄存器，常用于计数；常用于保存计算值，如在移位指令，循环（Loop）和串处理中用作隐含的计数器。
4. DX（Data）：数据寄存器，常用于数据传递；双字长场数据的高 16 位，或存放

以上这 4 个寄存器，可以分为高 8 位：AH，BH，CH，DH；以及低 8 位：AL，BL，CL，DL。这 2 组 八位寄存器可以分别寻址，并单独使用。



另一组是**指针寄存器**和**变址寄存器**，包括：

1. SP（Stack Pointer）：堆栈指针，与 SS 配合使用，可指向目前的堆栈位置，不能用于其他目的，具有专用目的
2. BP（Base Pointer）：基址指针寄存器，可用作 SS 的一个相对基址位置

SP 和 BP 寄存器与 SS 段寄存器联合使用以确定堆栈段中的存储单元地址。



1. SI（Source Index）：源变址寄存器，可用来存放相对于 DS 段之源变址指针
2. DI（Destination Index）：目的变址寄存器，可以用来存放相对于 ES 段之目的变址指针。

串操作类指令中，SI 和 DI 具有特别的功能。

##### 堆栈

采用先进后出 FILO（First In Last Out）或者后进先出 LIFO（Last In Fist Out）的原则进行存取操作，而不是随机存取操作方式。

堆栈通常由处理器自动维持。在 8086 中，由堆栈段寄存器 SS 和堆栈指针寄存器 SP 共同指示。SP 指向栈顶，BP 指向值参的首地址。

##### 指令指针 IP

1. 指令指针寄存器 IP，指示代码段中指令的偏移地址
2. 它与代码段寄存器 CS 联用，确定下一条指令的物理地址
3. 计算机通过 CS：IP 寄存器来控制指令序列的执行流程
4. IP 寄存器是一个专用寄存器

#### 标志寄存器

标志（Flag）用于反映指令执行结果或控制指令执行形式，8086 处理器的各种标志形成了一个 16 位的标志寄存器 FLAGS（程序状态字 PSW 寄存器）

`程序设计需要利用标志的状态`



状态标志：用来记录程序运行结果的状态信息，许多指令的执行都将相应地设置它。

CF、ZF、SF、PF、OF、AF

控制标志：可由程序根据需要用指令设置，用于控制处理器执行指令的方式

DF、IF、TF



1. 进位标志 CF（Carry Flag）：当运算结果的最高有效进位（加法）或借位（减法）时，进位标志置 1，即 CF = 1；否则 CF = 0
2. 零标志 ZF（Zero Flag）：若运算结果为 0，则 ZF = 1，否则 ZF = 0（`注意`：ZF 为 1 表示结果是 0）
3. 符号标志 SF（Sign Flag）：运算结果最高位为 1，则 SF = 1；否则 SF = 0
4. 奇偶标志 PF（Parity Flag）：当运算结果最低字节中「1」的个数为零或偶数时，PF = 1；否则 PF = 0（`注意`：PF 标志尽反映最低 8 位中「1」的个数，即使是 16 位字操作）
5. 溢出标志 OF（Overflow Flag）：算术运算结果有溢出则为1（`注意`：溢出与进位的不同）
6. 辅助进位标志 AF（Auxiliary Carry Flag）：运算时 $D_3$ 位（低半子节）有进位或借位时，AF = 1；否则 AF = 0。（这个标志主要由处理器内部使用，用于十进制算数运算调整指令中，用户一般不必关心）
7. 方向标志 DF（Direction Flag）：用于串操作指令中，控制地址的变化方向。（设置 DF = 0，存储器地址自动增加；设置 DF = 1，存储器地址自动减少）CLD 指令复位方向标志：DF = 0；STD 指令置位方向标志：DF = 1；
8. 中断允许标志 IF（Interrupt-enable Flag）：用于控制外部可屏蔽中断是否可以被处理器相应。（IF = 1，允许中断）CLI 指令复位中断标志：IF = 0；STI 指令置位中断标志：IF = 1
9. 陷阱标志 TF（Trap Flag）：用于控制处理器进入但不操作方式（TF = 0：正常；1：单步）
   - 单步执行指令：处理器在每条指令执行结束时，便产生一个编号为 1 的内部中断，这种内部中断被称为**单步中断**
   - 所以 TF 也称为**单步标志**，利用单步中断可以对程序进行逐条指令的调试，这种逐条指令调试程序的方法就是单步**调试**

#### 段寄存器

8086 有 4 个 16 位段寄存器（分别指明各段的起始地址）：CS（代码段）、SS（堆栈段）、DS（数据段）、ES（附加段）

每个段寄存器用来确定一个逻辑段的起始地址，每种逻辑段均有各自的用途

32 / 64 位 CPU 采用段选择子——数组下标 / 段表述符表 —— 数组（含段地址、范围、权限等）的形式来确定段地址



##### 段值的确定

1. 一个执行文件执行时，首先由操作系统分析程序的段占用情况；包括多少段，每段的长度，代码段第一条指令的偏移
2. 然后在当前内存中寻找合适区域，并分配 CS、DS、SS、ES 等各段
3. 把执行文件中的数据调入内存 DS 段，代码调入 CS 段
4. 然后把 CPU 的 CS 变成当前分配的代码段值，IP 位第一条指令的便宜，从而开始程序的执行
5. SP 位堆栈段的大小（最大值 -wB）
6. 在汇编程序时，通过交叉文件可以看出各段的大小

#### 8086 的指令系统

8086 / 8088 的指令系统包含了六种类型，其中数据传送指令 14 条，算术运算指令 20 条，逻辑运算指令 13 条，串操作指令 10 条，控制转移指令 28 条，处理器控制指令 12 条。

##### 数据传送指令

1. **MOV** DST SRC：传送（Move）。目的数可以是通用寄存器、存储单元、段寄存器，CS 段寄存器除外；<u>不允许两个存储单元或段寄存器直接传送</u>；
2. **PUSH** SRC，**POP** DST：堆栈操作（Push onto / Pop from the stack）
   - PUSH 操作：SP = SP - 2；(SP, SP + 1) = SRC
   - POP 操作：DST = (SP + 1, SP)；SP = SP + 2
3. **XCHG** OPR1,OPR2：交换（Exchange）。不能与段寄存器交换数据；存储器之间不能交换

##### 累加器专用传送指令

1. **IN**（Input）输入
   1. 长格式：**IN** AL,PORT（字节）；**IN** AX, PORT（字）：
   - 执行的操作：AL = PORT（字节），AX = (wPORT + 1, PORT)（字）
   2. 短格式：**IN** AL, DX（字节）；**IN** AX, DX（字）

2. **OUT**（Output）输出